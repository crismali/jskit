{"name":"Jskit","tagline":"Deterministically execute javascript in your web application with minimum coupling to your server side","body":"JSKit\r\n=====\r\n\r\nJSKit is a tiny library to end the problem of jQuery soup and `$(document).ready()` mess. JSKit introduces a simple, clean, and easily testable way to architect basic javascript enhanced web pages. Based on a simple event system, JSKit allows your back-end application seamlessly integrate your javacsript code with minimal coupling.\r\n\r\nTable of Contents\r\n-----------------\r\n1. [Installation](#installation)\r\n2. [Basic Usage](#basic-usage)\r\n3. [Dispatcher](#dispatcher)\r\n4. [Controllers](#controllers)\r\n5. [Testing](#testing)\r\n6. [Contributing](#contributing)\r\n\r\n\r\nInstallation\r\n---------------\r\n\r\n### Download\r\n* Download the latest version\r\n  * [jskit.js](https://raw.githubusercontent.com/daytonn/jskit/master/dist/jskit.js)\r\n  * [jskit.min.js](https://raw.githubusercontent.com/daytonn/jskit/master/dist/jskit.min.js)\r\n* Include Script\r\n  * include the `dist/jskit.js` file in your application\r\n\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"path/to/jskit.js\"></script>\r\n```\r\n\r\n\r\nBasic Usage\r\n-----------\r\nThe `Application` is the interface to your JSKit components. To create an application you simply call `createApplication`:\r\n\r\n```js\r\nvar App = JSKit.createApplication();\r\n```\r\n\r\n### Dispatcher\r\n\r\nEvery application has a `Dispatcher` that allows registry and triggering of events throughout your JSKit application. In fact, JSKit is basically a thin wrapper around the `Dispatcher` that allows you to coordinate your javascript with minimal friction.\r\n\r\n```js\r\nApp.Dispatcher.on(\"some-event-name\", function() {\r\n    // handle some-event-name\r\n});\r\n\r\nApp.Dispatcher.trigger(\"some-event-name\");\r\n```\r\n\r\nGenerally you will not have to manually register for events (`App.Dispatcher.on`) since JSKit `Controllers` register their own actions automatically.\r\n\r\n### Creating Controllers\r\n\r\nThe basic component of a JSKit application is a Controller. Controllers are basically objects that map actions to events. To create a controller, call `createController`:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  actions: [\"index\", \"show\", \"new\", \"edit\"],\r\n\r\n  index: function() {\r\n    // handle index action\r\n  },\r\n\r\n  show: function() {\r\n    // handle show action\r\n  }\r\n\r\n  new: function() {\r\n    // handle new action\r\n  }\r\n\r\n  edit: function() {\r\n    // handle edit action\r\n  }\r\n})\r\n```\r\n\r\nWhen the `Application` creates a controller, it handles injecting the Controller with it's `Dispatcher`, creating the Controller's constructor, and instantiating an instance of the controller.\r\n\r\nController instances are stored in `Application.Controllers` by name. Looking at the \"Post\" controller example above we know that there is an instance of a \"Post\" Controller in\r\n\r\n```js\r\nApp.Controllers.Post\r\n```\r\n\r\nController constructors are stored on the `Application` object itself with the suffix \"Controller\".\r\nand the `PostController` class constructor is at\r\n\r\n```js\r\nApp.PostController\r\n```\r\n\r\nThe Controller instance is what `Application` will use at runtime. The Controller's constructor is simply a convenience for creating clean states for testing.\r\n\r\n<!-- TODO document name munging -->\r\n\r\nControllers\r\n-----------\r\nControllers are the main component of a JSKit `Application`. Controllers accpet a single argument of a Dispatcher. The Dispatcher is passed automatically when a controller is created with the `Application.createController` method. Generally, you will only instantiate `Controller`s in your tests. Having the Dispatcher injected makes testing them in isolation much easier.\r\n\r\n### Actions\r\n\r\nActions define which events your controller responds to. The `Controller` uses the `actions` array to map it's methods to the Dispatcher's events. Actions are automatically mapped to the Dispatcher when the `Controller` is instantiate. There are two ways to define an action mapping in your `Controller`s:\r\n\r\n#### Named Actions\r\n\r\nTo map an action by name, simply provide the method name as a string in the actions array:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  actions: [\"foo\"],\r\n  \r\n  foo: function() {\r\n    // handle \"controller:posts:foo\" event\r\n  }\r\n});\r\n```\r\n\r\n#### Mapped Actions\r\n\r\nSometimes you may want to map an action to a specific method, or you may want to bind two actions to the same method, to do so simply provide an object keyed by the action name with value of the method name:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  actions: [{ new: \"setupForm\" }, { edit: \"setupForm\" }],\r\n  \r\n  setupForm: function() {\r\n    // handle \"controller:posts:new\" and \"controller:posts:edit\" events\r\n  }\r\n});\r\n```\r\n\r\n### Action Mapping\r\n\r\nWhen an action is mapped, it will be registered on the dispatcher for a specific event. The event that is registered depends on a few properties of the `Controller`: `namspace`, `channel`, `name`, and `action`. The default values for these are:\r\n\r\n    namespace = \"\"\r\n    channel = \"controller\"\r\n    controllerEventName = \"<Controller.name>\" (lowercase and underscored)\r\n    action = \"<action>\r\n    eventSeperator = \":\"\r\n\r\nSo using the above examples, the event maps for the `PostsController` are:\r\n\r\n    controller:posts:foo  -> Controller.foo\r\n    controller:posts:new  -> Controller.setupForm\r\n    controller:posts:edit -> Controller.setupForm\r\n    \r\n*Note: undefined/empty values effectively removes that segment from the event name*\r\n    \r\n      \r\n#### namespace\r\n\r\nBy default `Controller`s have an empty namespace. If you wish to prefix the events the `Controller` registers for with an namespace, set this property:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  namespace: \"admin\"\r\n  ...\r\n});\r\n```\r\n\r\nThis will register all events with the `namespace` prefix:\r\n\r\n    admin:controller:posts:foo  -> Controller.foo\r\n    admin:controller:posts:new  -> Controller.setupForm\r\n    admin:controller:posts:edit -> Controller.setupForm\r\n\r\n#### channel\r\n\r\nThe default channel for a `Controller` is `controller`. To change this simply set the channel:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  channel: \"pages\"\r\n  ...\r\n});\r\n```\r\n\r\nThis will register all events with the `channel`:\r\n\r\n    pages:posts:foo  -> Controller.foo\r\n    pages:posts:new  -> Controller.setupForm\r\n    pages:posts:edit -> Controller.setupForm\r\n    \r\n#### controllerEventName\r\n\r\nThe `Controller` is given a `name` property by the `Application.createController(name, attributes)` method. The `controllerEventName` is automatically createds by lowercasing and underscoring the `name` to normalize event names. The `PostsController` example has the `name` \"Posts\" and a `controllerEventName` of \"posts\". CamelCased names will have underscores between each uppercased word:\r\n\r\n```js\r\nApp.createController(\"CamelCase\");\r\n```\r\n\r\nThis would register all events with the controller `controllerEventName` of `camel_case`:\r\n\r\n    controller:camel_case:<action> -> Controller.<action>\r\n    \r\n#### eventSeperator\r\n\r\nThe `eventSeperator` property defines how the `namespace`, `channel`, `name`, and `action` will be joined to create an event name. You can change this by setting the `eventSeperator` on the `Controller`:\r\n\r\n```js\r\nApp.createController(\"Posts\", {\r\n  eventSeperator: \".\"\r\n  ...\r\n});\r\n```\r\n\r\nThis would register all events using \".\" as a seperator:\r\n\r\n    controller.posts.foo  -> Controller.foo\r\n    controller.posts.new  -> Controller.setupForm\r\n    controller.posts.edit -> Controller.edit\r\n    \r\n### actionEventName\r\n\r\nThe `actionEventName` method allows you to get the full event name of a given action. It returns the `namespace`, `channel`, `controllerEventName`, and the `action` joined by the `eventSeperator`:\r\n\r\n```js\r\nvar controller = App.createController(\"Posts\");\r\ncontroller.actionEventName(\"index\"); // controller:posts:index\r\ncontroller.actionEventName(\"show\"); // controller:posts:show\r\ncontroller.actionEventName(\"new\"); // controller:posts:new\r\ncontroller.actionEventName(\"edit\"); // controller:posts:edit\r\ncontroller.actionEventName(); // controller:posts\r\n```\r\n\r\n### className\r\n\r\nEvery Controller has a `className`. The `className` property is generated by capitalizing the `name` and adding the suffix \"Controller\". This property is used to display the Controller's constructor name in error output. Given the \"Posts\" Controller, the `controllerName` would be: `PostsController`.\r\n\r\nTesting\r\n-------\r\n\r\nJSKit is all about making testing javascript easier. JSKit itself comes with some handy tools for testing JSKit applications. When you create a controller with the `Application.createController` method. The created Controller's constructor will be available on the `Application` object using the Controller's `className`. Using the \"Posts\" controller example:\r\n\r\n```js\r\nApp.PostsController\r\n```\r\n\r\n**_ALWAYS_** use the provided constructors when testing your Controllers to ensure you don't pollute your tests with mutated state.\r\n\r\n### TestDispatcher\r\n\r\nThe `TestDispatcher` is used to help test JSKit Controllers. You should always use the `TestDispatcher` when testing Controllers. To create a controller with the `TestDispatcher` simply pass it to the Controller:\r\n\r\n```js\r\ndescribe(\"PostsController\", function() {\r\n  var subject;\r\n  var dispatcher;\r\n  \r\n  beforeEach() {\r\n    dispatcher = new JSKit.TestDispatcher;\r\n    subject = new App.PostsController(dispatcher);\r\n  }\r\n  ...  \r\n};\r\n```\r\n\r\n#### spies\r\n\r\nWhen your Controller registers events on the `TestDispatcher`, your Controller's action methods will be enhanced with properties to determine if and how they were called:\r\n\r\n```js\r\n...\r\nit(\"calls index when the index event is triggered\", function() {\r\n  dispatcher.trigger(controller.actionEventName(\"index\"));\r\n  \r\n  expect(controller.index.called).to.equal(true);\r\n  expect(controller.index.callCount).to.equal(1);\r\n  expect(controller.index.calls[0].args).to.be.an(\"Array\");\r\n  expect(controller.index.calls[0].args).to.be.empty();\r\n});\r\n...   \r\n};\r\n```\r\n\r\n### hasAction\r\n\r\nMost of the time, you will not need the extra functionality provided by spies and you simply want to see if a Controller's actions are wired up correctly. You can do this simply by calling `hasAction` with the controller and action you wish to test:\r\n\r\n```js\r\n...\r\nvar subject;\r\nvar dispatcher;\r\n  \r\nbeforeEach() {\r\n  dispatcher = new JSKit.TestDispatcher;\r\n  subject = new App.PostsController(dispatcher);\r\n}\r\n  \r\nit(\"has an index action\", function() {\r\n  expect(dispatcher.hasAction(subject, \"index\")).to.equal(true);\r\n});\r\n...\r\n```\r\n\r\nContributing\r\n------------\r\n1. [Fork it](https://github.com/daytonn/jskit/fork)\r\n2. Clone it locally\r\n3. Set the upstream remote (`git remote add upstream git@github.com:daytonn/jskit.git`)\r\n4. Run the specs with `npm test`\r\n5. Create your feature branch (`git checkout -b my-new-feature`)\r\n6. Commit your changes (`git commit -am 'Add some feature'`)\r\n7. Rebase from upstream (`git rebase upstream master`)\r\n8. Push to the branch (`git push origin my-new-feature`)\r\n9. Create new Pull Request","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}